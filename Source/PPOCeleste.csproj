<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <AssemblyName>PPOCeleste</AssemblyName>
    <RootNamespace>Celeste.Mod.PPOCeleste</RootNamespace>
    <LangVersion>latest</LangVersion>
    
    <CelestePrefix Condition="'$(CelestePrefix)' == '' And Exists('..\..\..\Celeste.dll')">..\..\..</CelestePrefix>
    <CelestePrefix Condition="'$(CelestePrefix)' == ''">lib-stripped</CelestePrefix>
    
    <ZippedFiles>..\everest.yaml;..\bin\**\*.*;..\Audio\**\*.*;..\Dialog\**\*.*;..\Graphics\**\*.*;..\Ahorn\**\*.*;..\Loenn\**\*.*;..\lib-native\**\*.*</ZippedFiles>
    <Platforms>x64</Platforms>
  </PropertyGroup>

  <ItemDefinitionGroup>
    <PackageReference PrivateAssets="all" ExcludeAssets="runtime" />
    <Reference Private="false" />
  </ItemDefinitionGroup>

  <ItemGroup>
    <PackageReference Include="CelesteAnalyzer" Version="*" />
    <PackageReference Include="CelesteMod.Publicizer" Version="*" CelesteAssembly="$(CelestePrefix)\Celeste.dll" />
    <PackageReference Include="Microsoft.ML" Version="4.0.2" />
    <PackageReference Include="MonoMod.RuntimeDetour" Version="25.3.1">
      <IncludeAssets>compile; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="MonoMod.Patcher" Version="25.0.0-prerelease.2" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.4" />

    <PackageReference Include="TorchSharp" Version="0.105.1" />
    <PackageReference Include="libtorch-cuda-12.1-win-x64" Version="2.5.1" />
  </ItemGroup>

  <ItemGroup>
    <Reference Include="$(CelestePrefix)\MMHOOK_Celeste.dll" Private="false" />
    <Reference Include="$(CelestePrefix)\FNA.dll" Private="false" />
  </ItemGroup>

  <Target Name="CopyFiles" AfterTargets="Build">
    <Copy SourceFiles="$(OutputPath)\$(AssemblyName).dll" DestinationFolder="..\bin" />
    <Copy SourceFiles="$(OutputPath)\$(AssemblyName).pdb" DestinationFolder="..\bin" />
  </Target>

  <Target Name="CopyTorchSharpNative" AfterTargets="Build">
    
    <PropertyGroup>
      <NugetStore Condition="'$(NuGetPackageRoot)' == ''">$(UserProfile)\.nuget\packages</NugetStore>
      <NugetStore Condition="'$(NuGetPackageRoot)' != ''">$(NuGetPackageRoot)</NugetStore>

      <LibTorchSource>$(NugetStore)\libtorch-cuda-12.1-win-x64\2.5.1*\runtimes\win-x64\native</LibTorchSource>
      <TorchSharpSource>$(NugetStore)\torchsharp\0.105.1\lib\net6.0</TorchSharpSource>
    </PropertyGroup>

    <Message Text="ðŸ” Recherche des DLLs natives dans : $(LibTorchSource)" Importance="high" />

    <ItemGroup>
      <TorchNativeFiles Include="$(LibTorchSource)\*.dll" />
      <TorchManagedFiles Include="$(TorchSharpSource)\*.dll" />
    </ItemGroup>

    <MakeDir Directories="..\lib-native" />
    <MakeDir Directories="..\bin" />

    <Error Condition="'@(TorchNativeFiles)' == ''" Text="âŒ ERREUR : Aucune DLL native trouvÃ©e dans $(LibTorchSource). VÃ©rifie que le paquet est bien tÃ©lÃ©chargÃ©." />

    <Copy SourceFiles="@(TorchNativeFiles)" DestinationFolder="..\lib-native" SkipUnchangedFiles="true" />
    <Copy SourceFiles="@(TorchNativeFiles)" DestinationFolder="..\bin" SkipUnchangedFiles="true" />
    <Copy SourceFiles="@(TorchManagedFiles)" DestinationFolder="..\bin" SkipUnchangedFiles="true" />

    <Message Text="âœ… Copie terminÃ©e : $(LibTorchSource) -> ../bin" Importance="high" />
  </Target>

  <Target Name="PackageMod" AfterTargets="CopyFiles;CopyTorchSharpNative"
          Inputs="$(ZippedFiles)" Outputs="..\PPOCeleste.zip"
          Condition="'$(Configuration)' == 'Release'">
    <ItemGroup>
      <FilesToPackage Include="$(ZippedFiles)" />
    </ItemGroup>
    <PackageMod Files="@(FilesToPackage)" OutputPath="..\PPOCeleste.zip" />
  </Target>

  <PropertyGroup>
    <PathMap>$(MSBuildProjectDirectory)=PPOCeleste/</PathMap>
  </PropertyGroup>

  <UsingTask TaskName="PackageMod" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Files ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <OutputPath ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.IO.Compression" />
      <Code Type="Fragment" Language="cs">
      <![CDATA[
        var projectDir = Path.Combine(@"$(ProjectDir)", "..");
        projectDir = Uri.UnescapeDataString(projectDir);
        if (File.Exists(OutputPath)) File.Delete(OutputPath);
        using (ZipArchive zip = ZipFile.Open(OutputPath, ZipArchiveMode.Create)) {
            foreach (var file in Files) {
                string filePath = file.GetMetadata("FullPath");
                if(!File.Exists(filePath)) continue;
                string entryName = GetRelativePath(projectDir, filePath);
                zip.CreateEntryFromFile(filePath, entryName);
            }
        }
        string GetRelativePath(string fromPath, string toPath) {
            if (string.IsNullOrEmpty(fromPath)) throw new ArgumentNullException(nameof(fromPath));
            if (string.IsNullOrEmpty(toPath)) throw new ArgumentNullException(nameof(toPath));
            Uri fromUri = new Uri(fromPath);
            Uri toUri = new Uri(toPath);
            if (fromUri.Scheme != toUri.Scheme) return toPath;
            Uri relativeUri = fromUri.MakeRelativeUri(toUri);
            string relativePath = Uri.UnescapeDataString(relativeUri.ToString());
            if (toUri.Scheme.Equals("file", StringComparison.InvariantCultureIgnoreCase))
                relativePath = relativePath.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
            return relativePath;
        }
      ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>