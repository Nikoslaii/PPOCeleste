<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <AssemblyName>PPOCeleste</AssemblyName>
    <RootNamespace>Celeste.Mod.PPOCeleste</RootNamespace>
    <LangVersion>latest</LangVersion>
    <CelestePrefix Condition="'$(CelestePrefix)' == '' And Exists('..\..\..\Celeste.dll')">..\..\..</CelestePrefix>
    <CelestePrefix Condition="'$(CelestePrefix)' == ''">lib-stripped</CelestePrefix>
    
    <!-- Ajout de lib-native dans les fichiers Ã  zipper -->
    <ZippedFiles>..\everest.yaml;..\bin\**\*.*;..\Audio\**\*.*;..\Dialog\**\*.*;..\Graphics\**\*.*;..\Ahorn\**\*.*;..\Loenn\**\*.*;..\lib-native\**\*.*</ZippedFiles>
    
    <Platforms>x64</Platforms>
  </PropertyGroup>

  <ItemDefinitionGroup>
    <PackageReference PrivateAssets="all" ExcludeAssets="runtime" />
    <Reference Private="false" />
  </ItemDefinitionGroup>

  <ItemGroup>
    <PackageReference Include="CelesteAnalyzer" Version="*" />
    <PackageReference Include="CelesteMod.Publicizer" Version="*" CelesteAssembly="$(CelestePrefix)\Celeste.dll" />
    <PackageReference Include="Microsoft.ML" Version="4.0.2" />
    <PackageReference Include="MonoMod.RuntimeDetour" Version="25.3.1">
      <IncludeAssets>compile; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="MonoMod.Patcher" Version="25.0.0-prerelease.2" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.4" />
    
    <!-- 
      IMPORTANT : Utilisation de la version CUDA pour l'accÃ©lÃ©ration GPU.
      GeneratePathProperty="true" permet de crÃ©er une variable $(PkgTorchSharp) pour trouver le chemin.
    -->
    <PackageReference Include="TorchSharp" Version="0.105.1" GeneratePathProperty="true" />
    <PackageReference Include="libtorch-cuda-12.1-win-x64" Version="2.5.1" GeneratePathProperty="true" />
  </ItemGroup>

  <ItemGroup>
    <Reference Include="$(CelestePrefix)\MMHOOK_Celeste.dll" Private="false" />
    <Reference Include="$(CelestePrefix)\FNA.dll" Private="false" />
  </ItemGroup>

  <!-- Copie standard du DLL du mod -->
  <Target Name="CopyFiles" AfterTargets="Build"
          Inputs="$(OutputPath)\$(AssemblyName).dll;$(OutputPath)\$(AssemblyName).pdb"
          Outputs="..\bin\$(AssemblyName).dll;..\bin\$(AssemblyName).pdb">
    <Copy SourceFiles="$(OutputPath)\$(AssemblyName).dll" DestinationFolder="..\bin" />
    <Copy SourceFiles="$(OutputPath)\$(AssemblyName).pdb" DestinationFolder="..\bin" />
  </Target>

  <!-- 
    ðŸ§© Copie automatique des DLL natives TorchSharp 
    Elles vont dans le dossier "../lib-native" pour Ãªtre zippÃ©es proprement ensuite.
  -->
  <Target Name="CopyTorchSharpNative" AfterTargets="Build">
    <Message Text="Copie des librairies natives TorchSharp..." Importance="high" />
    
    <!-- RÃ©cupÃ©ration dynamique des fichiers depuis le cache NuGet -->
    <ItemGroup>
      <TorchNativeFiles Include="$(Pkglibtorch_cuda_12_1_win_x64)\runtimes\win-x64\native\*.*" />
      <TorchManagedFiles Include="$(PkgTorchSharp)\lib\net8.0\*.dll" />
    </ItemGroup>
    
    <!-- CrÃ©ation du dossier si inexistant -->
    <MakeDir Directories="..\lib-native" />
    
    <!-- Copie des fichiers natifs (libtorch) -->
    <Copy SourceFiles="@(TorchNativeFiles)" DestinationFolder="..\lib-native" SkipUnchangedFiles="true" />
    
    <!-- Copie des DLLs managÃ©es (TorchSharp.dll) dans bin pour le loader -->
    <Copy SourceFiles="@(TorchManagedFiles)" DestinationFolder="..\bin" SkipUnchangedFiles="true" />
    
    <!-- Copie Ã©galement dans lib-native pour le prÃ©-chargement manuel -->
    <Copy SourceFiles="@(TorchManagedFiles)" DestinationFolder="..\lib-native" SkipUnchangedFiles="true" />
  </Target>

  <!-- Zip builder -->
  <Target Name="PackageMod" AfterTargets="CopyFiles;CopyTorchSharpNative"
          Inputs="$(ZippedFiles)" Outputs="..\PPOCeleste.zip"
          Condition="'$(Configuration)' == 'Release'">
    <ItemGroup>
      <FilesToPackage Include="$(ZippedFiles)" />
    </ItemGroup>
    <PackageMod Files="@(FilesToPackage)" OutputPath="..\PPOCeleste.zip" />
  </Target>

  <PropertyGroup>
    <PathMap>$(MSBuildProjectDirectory)=PPOCeleste/</PathMap>
  </PropertyGroup>

  <!-- TÃ¢che Inline pour crÃ©er le ZIP -->
  <UsingTask TaskName="PackageMod" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Files ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <OutputPath ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.IO.Compression" />
      <Code Type="Fragment" Language="cs">
      <![CDATA[
        var projectDir = Path.Combine(@"$(ProjectDir)", "..");
        projectDir = Uri.UnescapeDataString(projectDir);

        if (File.Exists(OutputPath))
            File.Delete(OutputPath);

        using (ZipArchive zip = ZipFile.Open(OutputPath, ZipArchiveMode.Create))
        {
            foreach (var file in Files)
            {
                string filePath = file.GetMetadata("FullPath");
                // Protection contre les fichiers manquants
                if(!File.Exists(filePath)) continue;

                string entryName = GetRelativePath(projectDir, filePath);
                zip.CreateEntryFromFile(filePath, entryName);
            }
        }

        string GetRelativePath(string fromPath, string toPath)
        {
            if (string.IsNullOrEmpty(fromPath)) throw new ArgumentNullException(nameof(fromPath));
            if (string.IsNullOrEmpty(toPath)) throw new ArgumentNullException(nameof(toPath));

            Uri fromUri = new Uri(fromPath);
            Uri toUri = new Uri(toPath);

            if (fromUri.Scheme != toUri.Scheme)
                return toPath;

            Uri relativeUri = fromUri.MakeRelativeUri(toUri);
            string relativePath = Uri.UnescapeDataString(relativeUri.ToString());

            if (toUri.Scheme.Equals("file", StringComparison.InvariantCultureIgnoreCase))
                relativePath = relativePath.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);

            return relativePath;
        }
      ]]>
      </Code>
    </Task>
  </UsingTask>

</Project>